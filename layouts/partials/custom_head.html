{{/* Minimal custom head for testing */}} {{/* Essential dark theme script only
*/}}
<script>
  (function () {
    "use strict";

    function getThemeMode() {
      try {
        const storedMode = localStorage.getItem("dark_mode");
        console.log("Theme init: stored dark_mode =", storedMode);
        return parseInt(storedMode || 2);
      } catch (e) {
        console.error("localStorage access failed:", e);
        return 2; // Default to auto if localStorage is blocked
      }
    }

    function shouldUseDarkTheme() {
      let currentThemeMode = getThemeMode();
      console.log("Theme init: currentThemeMode =", currentThemeMode);
      switch (currentThemeMode) {
        case 0:
          return false; // Light mode
        case 1:
          return true; // Dark mode
        default:
          try {
            if (localStorage.getItem("dark_mode") === null) {
              console.log("Theme init: No preference saved, defaulting to light");
              return false; // Default to light for new visitors
            }
          } catch (e) {
            console.error("localStorage check failed:", e);
          }
          return (
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          );
      }
    }

    // Apply theme immediately
    if (shouldUseDarkTheme()) {
      console.log("Theme init: Applying dark theme");
      document.documentElement.setAttribute("data-theme", "dark");
      document.documentElement.style.backgroundColor = "#0f172a";
      document.documentElement.style.color = "#e2e8f0";
      // Critical: Add dark class to body to match academic.js expectations
      document.addEventListener("DOMContentLoaded", function() {
        document.body.classList.add("dark");
        console.log("Theme init: Added dark class to body");
      });
    } else {
      console.log("Theme init: Applying light theme");
    }
  })();
</script>

{{ partial "publication-badges-css.html" . }}

{{/* Search modal styling */}}
<link rel="stylesheet" href="{{ "css/search-modal.css" | relURL }}" />

{{/* Tag cloud height constraint */}}
<link rel="stylesheet" href="{{ "css/tag-cloud-height.css" | relURL }}" />

{{/* Tag cloud network visualization - load without defer to debug */}}
<script src="{{ "js/tag-cloud-network.js" | relURL }}"></script>

{{/* Article ancillary tags - adds related tags to article pages */}}
<script src="{{ "js/article-ancillary-tags.js" | relURL }}"></script>

{{/* Basic performance optimization */}}
<meta name="format-detection" content="telephone=no" />

{{/* Search modal smart closing and query preservation - Simple Version */}}
<script>
  document.addEventListener("DOMContentLoaded", function () {
    setTimeout(function () {
      const searchModal = document.getElementById("search");
      if (!searchModal) return;

      let savedQuery = localStorage.getItem("searchQuery") || "";
      let savedResults = localStorage.getItem("searchResults") || "";
      window.searchModalPreventClose = false;

      // Function to check if there are search results
      function hasSearchResults() {
        const searchHits = document.getElementById("search-hits");
        return (
          searchHits && searchHits.querySelectorAll(".search-hit").length > 0
        );
      }

      // Function to save search results
      function saveSearchResults() {
        const searchHits = document.getElementById("search-hits");
        if (searchHits && hasSearchResults()) {
          savedResults = searchHits.innerHTML;
          localStorage.setItem("searchResults", savedResults);
          console.log("Saved search results");
        }
      }

      // Function to restore search results
      function restoreSearchResults() {
        if (savedResults) {
          const searchHits = document.getElementById("search-hits");
          if (searchHits) {
            searchHits.innerHTML = savedResults;
            console.log("Restored search results");
          }
        }
      }

      // Function to check if modal is visible
      function isModalVisible() {
        return (
          getComputedStyle(searchModal).display !== "none" &&
          searchModal.offsetParent !== null
        );
      }

      // Save query continuously
      function saveQuery() {
        const searchInput = document.getElementById("search-query");
        if (searchInput && searchInput.value.trim()) {
          savedQuery = searchInput.value;
          localStorage.setItem("searchQuery", savedQuery);
          console.log("Saved query:", savedQuery);
        }
      }

      // Restore query aggressively
      function forceRestoreQuery() {
        if (savedQuery) {
          const searchInput = document.getElementById("search-query");
          if (searchInput) {
            // Force set the value multiple ways
            searchInput.value = savedQuery;
            searchInput.setAttribute("value", savedQuery);
            searchInput.defaultValue = savedQuery;

            console.log("Force restored query:", savedQuery);

            // Trigger search
            searchInput.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }
      }

      // Watch for input changes and protect the value
      const searchInput = document.getElementById("search-query");
      if (searchInput) {
        // Store the original value property descriptor
        const originalDescriptor = Object.getOwnPropertyDescriptor(
          HTMLInputElement.prototype,
          "value"
        );

        // Override the value property to protect our saved query
        Object.defineProperty(searchInput, "value", {
          get: function () {
            const currentValue = originalDescriptor.get.call(this);
            // If someone tries to read an empty value but we have a saved query and modal is visible, return the saved query
            if (!currentValue && savedQuery && isModalVisible()) {
              console.log(
                "Intercepted empty value read, returning saved query:",
                savedQuery
              );
              return savedQuery;
            }
            return currentValue;
          },
          set: function (newValue) {
            console.log("Value being set to:", newValue);

            // If trying to set empty value while modal is visible and we have a saved query, ignore it
            if (!newValue && savedQuery && isModalVisible()) {
              console.log(
                "BLOCKED attempt to clear input while modal is visible"
              );
              return; // Don't set the empty value
            }

            // Otherwise, set the value normally
            originalDescriptor.set.call(this, newValue);

            // If setting a non-empty value, save it
            if (newValue && newValue.trim()) {
              savedQuery = newValue;
              localStorage.setItem("searchQuery", newValue);
              console.log("Saved new query via setter:", newValue);
            }
          },
          configurable: true,
        });

        searchInput.addEventListener("input", function () {
          if (this.value && this.value.trim()) {
            savedQuery = this.value;
            localStorage.setItem("searchQuery", this.value);
          }

          // Update prevent close status
          const hasResults = hasSearchResults();
          const hasQuery = this.value.trim().length > 0;
          window.searchModalPreventClose = hasResults || hasQuery;

          // Save results when they change due to new search
          if (hasResults) {
            setTimeout(saveSearchResults, 200); // Small delay to let search complete
          }
        });

        // Also set the initial value if we have a saved query
        if (savedQuery) {
          originalDescriptor.set.call(searchInput, savedQuery);
        }
      }

      // Monitor modal opening/closing
      new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          if (
            mutation.type === "attributes" &&
            (mutation.attributeName === "style" ||
              mutation.attributeName === "class")
          ) {
            const isVisible = isModalVisible();

            if (isVisible && !this.wasVisible) {
              // Modal opened - restore both query and results
              console.log("Modal opened");
              if (savedQuery && searchInput) {
                // Force the display of our saved query
                const originalDescriptor = Object.getOwnPropertyDescriptor(
                  HTMLInputElement.prototype,
                  "value"
                );
                originalDescriptor.set.call(searchInput, savedQuery);

                // Restore results first, then trigger input event
                if (savedResults) {
                  restoreSearchResults();
                }

                searchInput.dispatchEvent(
                  new Event("input", { bubbles: true })
                );
                console.log(
                  "Restored query and results on modal open:",
                  savedQuery
                );
              }
            }

            this.wasVisible = isVisible;
          }
        });
      }).observe(searchModal, {
        attributes: true,
        attributeFilter: ["style", "class"],
      });

      // Prevent background clicks when there are results
      searchModal.addEventListener("click", function (e) {
        if (e.target === searchModal) {
          const hasResults = hasSearchResults();
          const hasQuery = searchInput && searchInput.value.trim().length > 0;

          if (hasResults || hasQuery) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
          }
        }
      });

      // Save query and results on ESC
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape" && isModalVisible()) {
          saveQuery();
          saveSearchResults();
        }
      });

      // Set up observer to watch for search results changes and save them
      const searchHits = document.getElementById("search-hits");
      if (searchHits) {
        new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (mutation.type === "childList" && hasSearchResults()) {
              // Results changed, save them after a short delay
              setTimeout(saveSearchResults, 300);
            }
          });
        }).observe(searchHits, { childList: true, subtree: true });
      }
    }, 1000);
  });
</script>

{{/* IndexNow automatic submission */}} {{ if site.Params.indexnow.enabled }}
<script>
  window.addEventListener("load", function () {
    if (typeof IndexNowSubmission !== "undefined") {
      setTimeout(function () {
        IndexNowSubmission.submitCurrentPage();
      }, 2000);
    }
  });
</script>
{{ end }}
